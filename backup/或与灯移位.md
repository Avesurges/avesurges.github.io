##  |(或)  :  有一个是1就取1,否则取0 , <<(左移),右侧空余补0,左侧多余舍去,>>(右移),左侧空余补0(无符号数)或符号位(有符号数),右侧多余舍去
# 灯移位v1：
```C
#include <reg51.h>
unsigned char leds,i;

void delay(void)
{
	int i,j;
	for(i=0;i<1000;i++)
		for(j=0;j<10;j++);
}



int main()
{
	leds = 0xFE;
	while(1)
	{
		leds = 0xFE;
		for(i=0;i<8;i++){
			P2 = leds;
			delay();
			leds<<=1;
			delay();
		}
	}
}

```
这段代码运行效果有点瑕疵,灯移位后补的0会导致上一个灯继续亮着，循环往复类似一个进度条的形式，然而并不需要这样

# 灯移位v2:
```C
#include <reg51.h>
unsigned char leds,i;

void delay(void)
{
	int i,j;
	for(i=0;i<1000;i++)
		for(j=0;j<10;j++);
}



int main()
{
	leds = 0xFE;
	while(1)
	{
		leds = 0xFE;
		for(i=0;i<8;i++){
			P2 = leds;
			delay();
			leds=(leds<<1)|0x01;
			delay();
		}
	}
}
````
这个版本是正确的,这里有个地方值得一究: (leds<<1)|0x01,为什么这样做就会把补的0变成1了呢

0x01即0000 0001,因为0 | 1 = 1,并且新补的0一定在最低位,刚好可以与这个"1"进行运算,这会导致其置1,从而熄灭
如果想让灯从右向左移,可以改为`leds=(leds>>1)|0x80;`(0x80即1000 0000)
同样的原理,这里补的0(leds是unsigned char)会被0x80最高位的1置1,从而熄灭

这种方法很巧妙,避免了使用`P2 &= ~(1 << previousIndex);`这样繁琐得显式关闭灯,体现位运算的妙处